// +build ignore

// Confusables dictionary generator
// See http://www.unicode.org/reports/tr39/

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"
)

func main() {
	parseConfusables()
	writeConfusablesMap()
}

const (
	// Confusables file
	// 	Format:
	// 		05AD ;	0596 ;	MA	# ( ֭ → ֖ ) HEBREW ACCENT DEHI → HEBREW ACCENT TIPEHA	#
	// 	See http://www.unicode.org/reports/tr39/ for full explanation
	ConfusablesFile = "../data/confusables.txt"
	// Output package name
	PackageName = "homographs"
	// Generated output file
	OutputFile = "homographs/confusables_map.go"
)

const (
	// Fields of each line
	CSourceCodePoint = iota
	CTargetCodePoint
	CType
	NumField
)

// Type C encapsulates a line of the confusables file
// 	(Character -> Skeleton Character(s))
type C struct {
	k rune
	v []rune
}

// Generated file header
var header []byte

// Array of confusables (Character -> Skeleton Character)
var confusables []C

// Parse unicode confusables
// 	Fills the header and confusable arrays
func parseConfusables() {
	// Open file
	f, err := os.Open(ConfusablesFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)
	// Parse header
	header = []byte("// Original header of the source confusables file:\n")
	for scanner.Scan() {
		if parseHeader(scanner.Text()) {
			break
		}
	}
	// Parse confusables
	for scanner.Scan() {
		parseLine(scanner.Text())
	}
	if scanner.Err() != nil {
		log.Fatal(scanner.Err())
	}
}

// Writes the confusables map (as a go source file)
func writeConfusablesMap() {
	out := "// DO NOT EDIT - File autogenerated with generate_confusables.go\n\n"
	out += "package " + PackageName + "\n\n"
	// Header
	out += fmt.Sprintf("%s\n", header)
	// Confusables
	out += fmt.Sprint("var confusablesMap = map[rune]string{\n")
	for _, c := range confusables {
		out += fmt.Sprintf("0x%.8X: %+q,\n", c.k, string(c.v))
	}
	out += fmt.Sprintln("}")
	// Open output file
	w, err := os.Create(OutputFile)
	if err != nil {
		log.Fatalf("Could not create file %s: %v", OutputFile, err)
	}
	defer w.Close()
	// Format content
	formatted, err := format.Source([]byte(out))
	if err != nil {
		w.Write([]byte(out))
		log.Fatalf("Error formatting output file: %v", err)
	}
	// Write content
	if _, err := w.Write(formatted); err != nil {
		log.Fatalf("Error writing output file: %v", err)
	}
}

// Parses a possible header line
// 	Appends the parsed header line to header
// 	Returns true if the line is no longer part of the header
func parseHeader(line string) bool {
	// If present, strip Byte Order Mark
	if len(line) > 3 && bytes.Compare(([]byte(line[0:3])), []byte{0xEF, 0xBB, 0xBF}) == 0 {
		line = line[3:]
	}
	// Content line
	if len(line) == 0 || line[0] != '#' {
		return true
	}
	// Comment original header and append it to the header array
	header = append(header, "//"+line[1:]+"\n"...)
	return false
}

// Parses a line and appends it to the confusables array
func parseLine(line string) {
	// Line without characters content
	if len(line) == 0 || line[0] == '#' {
		return
	}
	// Split into columns
	field := strings.Split(line, " ;\t")
	if len(field) != NumField {
		log.Fatalf("%5s: %d fields (expected %d)\n", line, len(field), NumField)
	}
	// Use only MA superset
	if !strings.HasPrefix(field[2], "MA") {
		return
	}
	// Source rune
	sourceRune := parseRune(field[CSourceCodePoint], line)
	// Array of target runes
	var targetRunes []rune
	for _, r := range strings.Split(field[CTargetCodePoint], " ") {
		targetRunes = append(targetRunes, parseRune(r, line))
	}
	// Append to the confusables array
	confusables = append(confusables, C{sourceRune, targetRunes})
}

// Parses a rune
func parseRune(s string, l string) rune {
	x, err := strconv.ParseUint(s, 16, 64)
	if err != nil {
		log.Fatalf("%.5s...: %s", l, err)
	}
	r := rune(x)
	if r == 0 {
		log.Fatalf("%5s: Unknown rune %X", l, r)
	}
	return r
}
